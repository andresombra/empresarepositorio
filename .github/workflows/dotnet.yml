# Workflow CI/CD para Sistema de Controle de Estoque Multi-Empresas
# Autor: Andre Sombra
# RepositÃ³rio: empresarepositorio

name: .NET CI/CD

on:
  push:
    branches: [ "main", "develop" ]
  pull_request:
    branches: [ "main", "develop" ]

env:
  # ConfiguraÃ§Ãµes globais
  DOTNET_VERSION: '8.0.x'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 'true'
  DOTNET_NOLOGO: 'true'
  DOTNET_CLI_TELEMETRY_OPTOUT: 'true'

jobs:
  # Job de Build e Testes
  build-and-test:
    name: Build e Testes
    runs-on: ubuntu-latest
    
    steps:
    # Checkout do cÃ³digo
    - name: ğŸ“¥ Checkout do repositÃ³rio
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # NecessÃ¡rio para anÃ¡lise de cÃ³digo
    
    # Setup do .NET
    - name: âš™ï¸ Setup .NET ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    # Cache dos pacotes NuGet
    - name: ğŸ“¦ Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/*.targets') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    
    # Definir caminho do projeto
    - name: ğŸ” Definir caminho do projeto
      run: |
        echo "ğŸ“ Projeto localizado em: ./Empresa/"
        echo "ğŸ“„ SoluÃ§Ã£o: ./Empresa/GerEmpresas.sln"
        echo "PROJECT_PATH=./Empresa" >> $GITHUB_ENV
        echo "SOLUTION_FILE=./Empresa/GerEmpresas.sln" >> $GITHUB_ENV
    
    # Restore das dependÃªncias
    - name: ğŸ”„ Restore dependÃªncias
      run: |
        echo "ğŸ”„ Restaurando dependÃªncias da soluÃ§Ã£o..."
        dotnet restore ${{ env.SOLUTION_FILE }} --verbosity minimal
    
    # VerificaÃ§Ã£o de formataÃ§Ã£o (se vocÃª usar dotnet format)
    - name: ğŸ¨ Verificar formataÃ§Ã£o do cÃ³digo
      run: |
        echo "ğŸ¨ Verificando formataÃ§Ã£o do cÃ³digo..."
        dotnet format ${{ env.SOLUTION_FILE }} --verify-no-changes --verbosity diagnostic
      continue-on-error: true # NÃ£o falhar o build por formataÃ§Ã£o
    
    # Build da aplicaÃ§Ã£o
    - name: ğŸ”¨ Build da aplicaÃ§Ã£o
      run: |
        echo "ğŸ”¨ Fazendo build da soluÃ§Ã£o..."
        dotnet build ${{ env.SOLUTION_FILE }} --no-restore --configuration Release --verbosity minimal
        echo "âœ… Build concluÃ­do com sucesso!"
    
    # Executar testes unitÃ¡rios
    - name: ğŸ§ª Executar testes unitÃ¡rios
      run: |
        echo "ğŸ§ª Executando testes da soluÃ§Ã£o..."
        dotnet test ${{ env.SOLUTION_FILE }} --no-build --configuration Release --verbosity minimal \
          --collect:"XPlat Code Coverage" \
          --results-directory ./TestResults/ \
          --logger trx
      continue-on-error: true # NÃ£o falhar se nÃ£o houver testes
    
    # Upload dos resultados de teste
    - name: ğŸ“Š Upload resultados dos testes
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: |
          ./TestResults/**/*
        retention-days: 30
    
    # Publicar relatÃ³rio de cobertura (se houver)
    - name: ğŸ“ˆ Publicar cobertura de cÃ³digo
      if: success()
      run: |
        echo "ğŸ¯ Cobertura de cÃ³digo processada"
        # Aqui vocÃª pode adicionar ferramentas como ReportGenerator
        # dotnet tool install -g dotnet-reportgenerator-globaltool
        # reportgenerator -reports:./TestResults/*/coverage.cobertura.xml -targetdir:./CoverageReport
      continue-on-error: true

  # Job de AnÃ¡lise de SeguranÃ§a (opcional)
  security-analysis:
    name: AnÃ¡lise de SeguranÃ§a
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: ğŸ“¥ Checkout do repositÃ³rio
      uses: actions/checkout@v4
    
    - name: âš™ï¸ Setup .NET ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    # VerificaÃ§Ã£o de vulnerabilidades em dependÃªncias
    - name: ğŸ” Verificar vulnerabilidades
      run: |
        echo "ğŸ” Verificando vulnerabilidades..."
        dotnet list ${{ env.SOLUTION_FILE }} package --vulnerable --include-transitive 2>&1 | tee vulnerability-report.txt
        if grep -q "has the following vulnerable packages" vulnerability-report.txt; then
          echo "âš ï¸ Vulnerabilidades encontradas!"
          cat vulnerability-report.txt
        else
          echo "âœ… Nenhuma vulnerabilidade encontrada"
        fi
      continue-on-error: true

  # Job de Deploy (apenas para branch main)
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [build-and-test, security-analysis]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: ğŸ“¥ Checkout do repositÃ³rio
      uses: actions/checkout@v4
    
    - name: âš™ï¸ Setup .NET ${{ env.DOTNET_VERSION }}
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    # Build para produÃ§Ã£o
    - name: ğŸ—ï¸ Build para produÃ§Ã£o
      run: |
        echo "ğŸ—ï¸ Fazendo build para produÃ§Ã£o..."
        dotnet restore ${{ env.SOLUTION_FILE }}
        # Publicar a API (assumindo que Ã© o projeto principal)
        dotnet publish ${{ env.PROJECT_PATH }}/Empresa.Api/Empresa.Api.csproj --configuration Release --output ./publish --no-restore
        echo "ğŸš€ AplicaÃ§Ã£o pronta para deploy!"
    
    # Upload do artefato para deploy
    - name: ğŸ“¤ Upload artefato de deploy
      uses: actions/upload-artifact@v4
      with:
        name: empresa-repositorio-app
        path: ./publish/
        retention-days: 90
    
    # Aqui vocÃª pode adicionar steps especÃ­ficos para seu ambiente de deploy
    # Por exemplo: Azure App Service, AWS, Docker, etc.
    - name: ğŸ¯ Notificar deploy
      run: |
        echo "ğŸ‰ Deploy realizado com sucesso!"
        echo "ğŸ“± Sistema Multi-Empresas de Controle de Estoque atualizado"

  # Job de NotificaÃ§Ã£o (opcional)
  notify:
    name: NotificaÃ§Ãµes
    runs-on: ubuntu-latest
    needs: [build-and-test, security-analysis, deploy]
    if: always()
    
    steps:
    - name: ğŸ“± Status do Pipeline
      run: |
        if [ "${{ needs.build-and-test.result }}" == "success" ]; then
          echo "âœ… Build e testes: SUCCESS"
        else
          echo "âŒ Build e testes: FAILED"
        fi
        
        if [ "${{ needs.security-analysis.result }}" == "success" ]; then
          echo "âœ… AnÃ¡lise de seguranÃ§a: SUCCESS"
        else
          echo "âš ï¸ AnÃ¡lise de seguranÃ§a: FAILED ou SKIPPED"
        fi
        
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "âœ… Deploy: SUCCESS"
        else
          echo "âš ï¸ Deploy: FAILED ou SKIPPED"
        fi
